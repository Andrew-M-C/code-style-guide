# tRPC 特有的一些命名模式

- [tRPC 特有的一些命名模式](#trpc-特有的一些命名模式)
  - [服务的名称](#服务的名称)
  - [目录](#目录)
  - [metrics 命名](#metrics-命名)

## 服务的名称

按照 tRPC 的建议，服务的名称应该是四个部份，一般如下：

- `trpc.应用名.服务名.模块名`

但是实际上根据 trpc 的架构，一个服务也就起一个模块，此外就是在单体 / 微服务的构架下，我们不太需要去强调 “服务” 和 “模块” 的分类，统一按照 “模块” 来暴露就行了，所以个人参照以下原则:

| 序号 | 项目 | 说明 | 举例 |
|:--:|:--:|:---|:--|
| 1 | 协议 | 表示当前服务对外提供的协议类型 | `trpc, http, mysql, redis, es` |
| 2 | 系统 | 表示当前服务所处的团队、大型项目名称 | 比如 `amc` 表示我个人的所有项目, 或者是 `qqmusic` 表示 QQ 音乐业务 |
| 3 | 平台 | 表示该功能属于什么大模块、什么平台, 比如说 QQ 音乐歌曲功能 |  |
| 3 | 模块 | 表示具体的服务类别 |  |

## 目录

服务仓库使用大仓模式构建，包含以下层级

- `app` - 存放各个应用程序（`main` 包）
  - `xxx`
    - 包说明
      - 表示某一个应用，直接就用应用的名称命名。应用名采用全小写+下划线格式命名。如无特别区分需求，无需加 `server`、`srv`、`service` 等额外描述
      - 除了单体应用或组合应用，基本上一个 main 包对应一个 PB service
    - `main.go` - `main` 函数所在位置。`main` 包不包含业务逻辑，仅包含trpc 环境初始化、依赖注入、`s.Serve()` 函数调用
    - `wire.go` - wire 模板文件位置
    - `wire_gen.go` - wire 工具生成的依赖注入文件
    - `service` - 目录，对应一个 PB service
    - `entity` - 用于当前 service 的实体定义
    - `logic` - 用于当前 service 的逻辑层代码
    - `repo` - 用于当前 service 的仓储、配置存取代码
    - `util` - 用于当前 service 的跨层小工具
      - `filter` - 用于当前 service 的 trpc filter 实现
- `entity` - 跨多个微服务的实体定义
- `logic` - 跨多个微服务的逻辑层代码
- `repo` - 跨多个微服务的仓储代码
- `util` - 跨多个微服务的小工具
- `filter` - 跨多个微服务的 trpc filter 实现

## metrics 命名

用于 tRPC 的 metrics 名称命名规则如下：

- namespace 模式，以点 `.` 分割，同一段内使用小写加下划线格式命名
- 每一个 package 上报的 metrics 名称应该为有一个前缀，各种情况如下：
  - 如果是 service 层，则前缀为 `xxx.`，其中 `xxx` 是服务名
  - 如果是 logic 层代码，则从 logic 层开始，按目录名指定前缀，如 `logic.user.`
  - 如果是 repo 层代码，则从 repo 层开始，按目录名指定前缀，如 `repo.user.`
  - 如果是 filter，则从 filter 层开始，按目录名指定前缀，如 `filter.tracelog.`
- 每一个 metrics 都需要包含后缀，包括以下几种情况：
  - 如果是 `gauge`（口径）类型的指标，则后缀为单位，比如某某耗时，当单位为微秒时，则加上后缀 `.usec`
  - 如果是 `count` 类型的指标，由于其值基本上均为 1，因此无需单位，但需要考虑以下情况：
    - 如果是单一指标，则加上 `.cnt` 后缀，表示次数
    - 如果是成功 / 失败类的成对指标，则相应地加上 `.succ` 和 `.fail` 后缀
- metrics 的中间部份，则 package 内部控制，同一组功能尽量保持相同的前缀
